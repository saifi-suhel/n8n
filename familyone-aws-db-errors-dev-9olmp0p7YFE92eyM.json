{"createdAt":"2025-10-03T09:39:07.690Z","updatedAt":"2025-10-07T06:13:42.000Z","id":"9olmp0p7YFE92eyM","name":"familyone-aws-db-errors-dev","active":false,"isArchived":false,"nodes":[{"parameters":{"jsCode":"function pick(v, fb = \"\") {\n  return (v ?? fb).toString().trim();\n}\n\nfunction parseIsoFromMessage(msg) {\n  // looks for e.g. 2025-09-19T11:04:26.355Z\n  const m = (msg || \"\").match(/\\b\\d{4}-\\d{2}-\\d{2}T[^\\sZ]*Z\\b/);\n  return m ? m[0] : \"\";\n}\n\nfunction parseLogMessage(fullMessage) {\n  const lines = fullMessage.split('\\n');\n  let timestamp_info = '';\n  let error = '';\n  let statement = '';\n  let current_tag = '';\n  let i = 0;\n  while (i < lines.length) {\n    let line = lines[i].trim();\n    if (line === '') {\n      i++;\n      continue;\n    }\n    if (!timestamp_info && line.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2} UTC:/)) {\n      const errorSplit = line.split(':ERROR:');\n      if (errorSplit.length > 1) {\n        timestamp_info = errorSplit[0].trim();\n        error = errorSplit[1].trim();\n        current_tag = 'ERROR';\n      } else {\n        // If no ERROR, perhaps it's the timestamp_info\n        timestamp_info = line.split(/:(HINT|DETAIL|STATEMENT|CONTEXT):/)[0].trim();\n      }\n    } else {\n      const tagMatch = line.match(/:(ERROR|HINT|DETAIL|STATEMENT|CONTEXT):/i);\n      if (tagMatch) {\n        const tag = tagMatch[1].toUpperCase();\n        const content = line.split(`:${tag}:`)[1].trim();\n        if (tag === 'ERROR') {\n          error = content;\n        } else if (tag === 'HINT' || tag === 'DETAIL' || tag === 'CONTEXT') {\n          if (error) {\n            error += `\\n${tag}: ${content}`;\n          }\n        } else if (tag === 'STATEMENT') {\n          statement = content;\n        }\n        current_tag = tag;\n      } else {\n        // Continuation of previous tag\n        if (current_tag === 'STATEMENT') {\n          statement += '\\n' + line;\n        } else if (current_tag === 'ERROR' || current_tag === 'HINT' || current_tag === 'DETAIL' || current_tag === 'CONTEXT') {\n          error += '\\n' + line;\n        }\n      }\n    }\n    i++;\n  }\n  return { timestamp_info, error, statement };\n}\n\n// Flatten any input item into error objects we need\nfunction extractFromItem(item) {\n  const results = [];\n  const payload = item?.json ?? {};\n\n  // If the payload is directly an errors array\n  if (Array.isArray(payload.errors)) {\n    for (const e of payload.errors) {\n      let message = pick(e.message || (e.sample ? e.sample.message : ''));\n      let parsed = { timestamp_info: '', error: '', statement: '' };\n      if (message) {\n        parsed = parseLogMessage(message);\n      } else if (e.error && e.statement) {\n        // If already parsed\n        parsed = {\n          timestamp_info: pick(e.timestamp_info),\n          error: pick(e.error),\n          statement: pick(e.statement)\n        };\n        message = `${parsed.timestamp_info}:ERROR: ${parsed.error}\\nSTATEMENT: ${parsed.statement}`;\n      }\n      const ts = pick(e.first_seen) || parseIsoFromMessage(message) || pick(e.last_seen) || parsed.timestamp_info;\n      const log_file = pick(e.log_file || e.logStream || (e.sample ? e.sample.logStream : ''));\n\n      results.push({\n        count: e.count ?? 1,\n        log_file,\n        timestamp_info: ts,\n        error: parsed.error,\n        statement: parsed.statement,\n      });\n    }\n    return results;\n  }\n\n  // If the payload itself looks like a single error object with sample\n  if (payload && typeof payload === \"object\" && !Array.isArray(payload)) {\n    const e = payload;\n    const s = e.sample || {};\n    let message = pick(s.message || e.message);\n    let parsed = { timestamp_info: '', error: '', statement: '' };\n    if (message) {\n      parsed = parseLogMessage(message);\n    } else if (e.error && e.statement) {\n      // If already parsed\n      parsed = {\n        timestamp_info: pick(e.timestamp_info),\n        error: pick(e.error),\n        statement: pick(e.statement)\n      };\n      message = `${parsed.timestamp_info}:ERROR: ${parsed.error}\\nSTATEMENT: ${parsed.statement}`;\n    }\n    const ts = pick(e.first_seen) || parseIsoFromMessage(message) || pick(e.last_seen) || parsed.timestamp_info;\n    const log_file = pick(e.log_file || s.logStream || e.logStream);\n\n    if (\"count\" in e || \"sample\" in e || \"message\" in e || \"error\" in e) {\n      results.push({\n        count: e.count ?? 1,\n        log_file,\n        timestamp_info: ts,\n        error: parsed.error,\n        statement: parsed.statement,\n      });\n      return results;\n    }\n  }\n\n  return results;\n}\n\n// MAIN: process ALL incoming items\nconst out = [];\nfor (const item of items) {\n  const rows = extractFromItem(item);\n  for (const r of rows) out.push({ json: r });\n}\n\nreturn out;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-100,0],"id":"a5d6ff7c-273f-4ded-bca3-57d3540916c1","name":"Code in JavaScript1"},{"parameters":{"url":"https://z2hyrn7craxrzcu2apbtnh7roi0fjudg.lambda-url.us-east-1.on.aws/","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-480,20],"id":"f64e2850-7a4c-4750-8662-788896720819","name":"HTTP Request"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"d9bc70b6-0400-4aa5-bba4-9cbec829b8a6","leftValue":"={{ $json.errors.length}}","rightValue":0,"operator":{"type":"number","operation":"gt"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-320,20],"id":"70d95fce-734d-4894-b7a1-5f4211356380","name":"If1"},{"parameters":{"options":{}},"type":"n8n-nodes-base.splitInBatches","typeVersion":3,"position":[640,0],"id":"a9294365-1292-4c2e-8d68-2a4960dd496f","name":"Loop Over Items3"},{"parameters":{"jsCode":"// Keep everything from the first literal \"ERROR\" onward.\n// Works even if the prefix uses tabs or spaces; also works if milliseconds are absent.\nconst stripPrefix = (s) => {\n  const str = (s ?? '').toString();\n  // Prefer robust \"from first ERROR\" cut:\n  const m = str.match(/\\bERROR\\b[\\s\\S]*/);\n  if (m) return m[0].trimStart();\n\n  // (Optional) stricter fallback: remove ISO timestamp + UUID prefix if present\n  return str.replace(\n    /^[ \\t]*\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z[ \\t]+[0-9a-fA-F]{8}(?:-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}[ \\t]+/,\n    ''\n  );\n};\n\nreturn items.map(item => {\n  const j = item.json || {};\n\n  if (Array.isArray(j.events)) {\n    j.events = j.events.map(ev => {\n      const cleaned = stripPrefix(ev.statement);\n      return { ...ev, statement: cleaned };\n    });\n    return { json: j };\n  }\n\n  if (typeof j.statement !== 'undefined') {\n    const cleaned = stripPrefix(j.statement);\n    return { json: { ...j, statement: cleaned } };\n  }\n\n  // pass through unchanged if no statement field\n  return item;\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[60,0],"id":"138f20cd-26c4-4017-9e17-d4b1b2857058","name":"editDescription1"},{"parameters":{"jsCode":"// ---- Helpers ----\nfunction summaryFromMessage(msg) {\n  msg = (msg ?? \"\").toString();\n\n  // Prefer text after TAB-ERROR-TAB (before '{' or newline)\n  const m = /\\tERROR\\t([^\\n{]+)/.exec(msg);\n  let base;\n  if (m) {\n    base = m[1].trim();\n  } else {\n    // Fallback to \"SomethingError: details\"\n    const m2 = /([A-Za-z]\\w*Error:\\s*[^\\n]+)/.exec(msg);\n    base = m2 ? m2[1].trim() : \"\";\n  }\n\n  if (!base) {\n    const firstLine = msg ? msg.split(/\\r?\\n/)[0].trim() : \"Error\";\n    base = firstLine.slice(0, 140);\n  }\n  return base.slice(0, 240); // Jira summary length guard\n}\n\nfunction descriptionFromEvent(ev) {\n  // Use statement if available, otherwise fallback to message\n  return (ev?.statement ?? ev?.message ?? \"\").toString().trim();\n}\n\n// builds: \"DATABASE [xN] <base> (<logGroup>) <timestamp>\"\nfunction buildSummary(ev) {\n  // For database errors, prefer the 'error' field over 'message'\n  const errorMsg = ev?.error ?? ev?.message ?? \"\";\n  const base = summaryFromMessage(errorMsg);\n  \n  const ts   = (ev?.timestamp ?? ev?.timestamp_info ?? \"\").toString().trim();\n  const lg   = (ev?.logGroup ?? ev?.log_file ?? \"\").toString().trim();\n\n  // prefer ev.count, else __count (propagated by collector)\n  const cnt = (typeof ev?.count === \"number\" ? ev.count : ev?.__count);\n  const cntPrefix = (typeof cnt === \"number\") ? `[x${cnt}] ` : \"\";\n  \n  // Add DATABASE prefix\n  const prefix = \"DATABASE \" + cntPrefix;\n\n  let summary = (base || \"Error\");\n  if (lg) summary += ` (${lg})`;\n  if (ts) summary += ` ${ts}`;\n  return prefix + summary;\n}\n\n// ---- Normalize input into a flat list of events, preserving count ----\nfunction collectEvents(items) {\n  const events = [];\n\n  for (const it of (items || [])) {\n    // If the tool upstream wrapped things in { json: ... }\n    const hasJson = it && Object.prototype.hasOwnProperty.call(it, \"json\");\n    const payload = hasJson ? it.json : it;\n\n    if (Array.isArray(payload)) {\n      // Case A: the item is already an array of event objects\n      for (const e of payload) {\n        if (e && (e.message || e.logGroup || e.logStream || e.error || e.statement)) {\n          events.push({ ...e, __count: typeof e.count === \"number\" ? e.count : undefined });\n        }\n      }\n      continue;\n    }\n\n    if (payload && Array.isArray(payload.events)) {\n      // Case B: { events: [...] }\n      for (const e of payload.events) {\n        if (e && (e.message || e.logGroup || e.logStream || e.error || e.statement)) {\n          // If the parent had a count and children don't, prefer child's own count\n          const c = (typeof e.count === \"number\")\n            ? e.count\n            : (typeof payload.count === \"number\" ? payload.count : undefined);\n          events.push({ ...e, __count: c });\n        }\n      }\n      continue;\n    }\n\n    if (payload && typeof payload === \"object\") {\n      // Case C: single event object per item (could be raw or in .json)\n      const e = payload;\n      if (e.message || e.logGroup || e.logStream || e.error || e.statement) {\n        const c = (typeof e.count === \"number\")\n          ? e.count\n          : (typeof payload.count === \"number\" ? payload.count : undefined);\n        events.push({ ...e, __count: c });\n      }\n    }\n  }\n\n  return events;\n}\n\n// ---- MAIN ----\nconst events = collectEvents(items);\n\nconst out = events.map(ev => ({\n  json: {\n    jiraSummary: buildSummary(ev),             // DATABASE [xN] error (log_file) timestamp\n    jiraDescription: descriptionFromEvent(ev), // complete SQL statement or message\n  }\n}));\n\nreturn out;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[440,0],"id":"aa6632fd-79a2-4602-9c13-461ecf45054b","name":"Summary&Description1","alwaysOutputData":true},{"parameters":{"jsCode":"// // === Helpers ===\n// const normalize = (s) =>\n//   (s ?? \"\")\n//     .toString()\n//     .replace(/\\s+/g, \" \") // collapse whitespace\n//     .trim();\n\n// // Build a description key for any event/item JSON\n// const descKeyFromJson = (j) => normalize(j.jiraDescription ?? j.statement ?? \"\");\n\n// // === 1) First pass: build frequency map across ALL inputs ===\n// const freq = new Map();  // key: normalized description, value: occurrence count\n\n// for (const item of items) {\n//   const j = item.json ?? {};\n\n//   if (Array.isArray(j.events)) {\n//     for (const ev of j.events) {\n//       const key = normalize(ev?.jiraDescription ?? ev?.statement ?? \"\");\n//       if (!key) continue;\n//       freq.set(key, (freq.get(key) ?? 0) + 1);\n//     }\n//   } else {\n//     const key = descKeyFromJson(j);\n//     if (!key) continue;\n//     freq.set(key, (freq.get(key) ?? 0) + 1);\n//   }\n// }\n\n// // === 2) Second pass: emit unique entries and attach counts ===\n// const out = [];\n// const seen = new Set(); // track which description keys we’ve already emitted (global)\n\n// for (const item of items) {\n//   const j = item.json ?? {};\n\n//   // A) One item that contains an array of events\n//   if (Array.isArray(j.events)) {\n//     const uniqueEvents = [];\n//     const seenLocal = new Set(); // local set to keep at most one event per description within this array\n\n//     for (const ev of j.events) {\n//       const key = normalize(ev?.jiraDescription ?? ev?.statement ?? \"\");\n//       if (!key) continue;\n\n//       // keep only the first event with this description within this array\n//       if (!seenLocal.has(key)) {\n//         seenLocal.add(key);\n\n//         // annotate this representative event with the total count of occurrences\n//         const annotated = { ...ev, count: freq.get(key) ?? 1 };\n//         uniqueEvents.push(annotated);\n//       }\n//     }\n\n//     // Add handy top-level stats (optional but useful for debugging/QA)\n//     const total = Array.isArray(j.events) ? j.events.length : 0;\n//     const uniqueCount = uniqueEvents.length;\n\n//     out.push({\n//       json: {\n//         ...j,\n//         events: uniqueEvents,\n//         // Keep your original count semantics if you want; or replace it.\n//         // Here we keep \"count\" as \"unique per description\" within this batch:\n//         count: uniqueCount,\n//         // Extra stats:\n//         total,\n//         duplicatesRemoved: Math.max(total - uniqueCount, 0),\n//       },\n//     });\n\n//     continue;\n//   }\n\n//   // B) Many items (streamed one per item)\n//   // Keep only the first occurrence of a given description across the stream\n//   const key = descKeyFromJson(j);\n//   if (!key) continue;\n\n//   if (!seen.has(key)) {\n//     seen.add(key);\n\n//     out.push({\n//       json: {\n//         ...j,\n//         // annotate the surviving item with how many times this description occurred overall\n//         count: freq.get(key) ?? 1,\n//       },\n//     });\n//   }\n// }\n\n// return out;\n\n\n// === CONFIGURATION: Choose your deduplication strategy ===\n// Strategy 1: Group by error + statement (strict matching)\n// Strategy 2: Group by error only (ignores statement differences)\n// Strategy 3: Group by error + log_file + date (time-based grouping)\n\nconst DEDUP_STRATEGY = \"error_and_statement\"; // Change as needed\n// Options: \"error_and_statement\", \"error_only\", \"error_and_logfile\"\n\n// === Helpers ===\nconst normalize = (s) =>\n  (s ?? \"\")\n    .toString()\n    .replace(/\\s+/g, \" \") // collapse whitespace\n    .trim();\n\n// Extract just the main error message (without HINT)\nconst getMainError = (errorStr) => {\n  const main = (errorStr ?? \"\").split(/\\nHINT:/)[0];\n  return normalize(main);\n};\n\n// Build grouping key based on strategy\nconst buildKey = (item, strategy) => {\n  const error = getMainError(item.error);\n  const statement = normalize(item.statement ?? \"\");\n  const logFile = normalize(item.log_file ?? \"\");\n  \n  switch (strategy) {\n    case \"error_only\":\n      return error;\n    \n    case \"error_and_logfile\":\n      return `${error}|||${logFile}`;\n    \n    case \"error_and_statement\":\n    default:\n      return `${error}|||${statement}`;\n  }\n};\n\n// === Step 1: Collect all events from input ===\nconst allEvents = [];\nfor (const item of items) {\n  const j = item.json ?? item;\n  \n  if (Array.isArray(j)) {\n    // Input is directly an array of events\n    allEvents.push(...j);\n  } else if (Array.isArray(j.events)) {\n    // Input has events array\n    allEvents.push(...j.events);\n  } else if (j.error || j.statement || j.log_file) {\n    // Single event object\n    allEvents.push(j);\n  }\n}\n\nconsole.log(`Total input events: ${allEvents.length}`);\n\n// === Step 2: Group by key and aggregate counts ===\nconst grouped = new Map();\n\nfor (const event of allEvents) {\n  const key = buildKey(event, DEDUP_STRATEGY);\n  \n  if (!key) continue; // Skip empty events\n  \n  if (!grouped.has(key)) {\n    // First occurrence: store the event with its count\n    grouped.set(key, {\n      ...event,\n      count: event.count ?? 1,\n      occurrences: 1 // Track how many times we've seen this\n    });\n  } else {\n    // Subsequent occurrence: add to existing count\n    const existing = grouped.get(key);\n    existing.count = (existing.count ?? 1) + (event.count ?? 1);\n    existing.occurrences += 1;\n    \n    // Keep the earliest timestamp\n    if (event.timestamp_info && \n        (!existing.timestamp_info || \n         event.timestamp_info < existing.timestamp_info)) {\n      existing.timestamp_info = event.timestamp_info;\n    }\n    \n    // Keep the first log_file seen\n    if (!existing.log_file && event.log_file) {\n      existing.log_file = event.log_file;\n    }\n  }\n}\n\n// === Step 3: Convert Map to array and sort ===\nconst uniqueEvents = Array.from(grouped.values())\n  .sort((a, b) => {\n    // Sort by timestamp if available\n    if (a.timestamp_info && b.timestamp_info) {\n      return a.timestamp_info.localeCompare(b.timestamp_info);\n    }\n    return 0;\n  });\n\nconsole.log(`Unique events after deduplication: ${uniqueEvents.length}`);\nconsole.log(`Duplicates removed: ${allEvents.length - uniqueEvents.length}`);\n\n// === Step 4: Format output (remove internal tracking field) ===\nconst out = uniqueEvents.map(event => {\n  const { occurrences, ...cleanEvent } = event; // Remove internal field\n  return {\n    json: cleanEvent\n  };\n});\n\n// === Optional: Print summary by error type ===\nconst errorSummary = {};\nfor (const event of uniqueEvents) {\n  const mainError = getMainError(event.error);\n  if (!errorSummary[mainError]) {\n    errorSummary[mainError] = { count: 0, occurrences: 0 };\n  }\n  errorSummary[mainError].count += event.count;\n  errorSummary[mainError].occurrences += event.occurrences;\n}\n\nconsole.log(\"\\n=== Error Summary ===\");\nfor (const [error, stats] of Object.entries(errorSummary)) {\n  console.log(`${error.substring(0, 60)}... → Total Count: ${stats.count}, Occurrences: ${stats.occurrences}`);\n}\n\nreturn out;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[240,0],"id":"3e01110c-775a-4c5c-a7c1-ec25a862ab2a","name":"removeDuplicatesBasisOnDescription1","alwaysOutputData":true},{"parameters":{"project":{"__rl":true,"value":"10198","mode":"list","cachedResultName":"rds-development"},"issueType":{"__rl":true,"value":"10166","mode":"list","cachedResultName":"Task"},"summary":"={{ $json.jiraSummary }}","additionalFields":{"description":"={{ String($json.jiraDescription ?? '').slice(0, 32700) }}"}},"type":"n8n-nodes-base.jira","typeVersion":1,"position":[860,20],"id":"43ca9d12-0b9f-456a-85da-a5b33b91207f","name":"Jira Software","credentials":{"jiraSoftwareCloudApi":{"id":"rSV4XrOrZ3lb8oK2","name":"Jira SW Cloud account-familyone"}}},{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[-640,20],"id":"ef34e32c-7d41-4319-98f8-48258a16634d","name":"When clicking ‘Test workflow’"}],"connections":{"Code in JavaScript1":{"main":[[{"node":"editDescription1","type":"main","index":0}]]},"HTTP Request":{"main":[[{"node":"If1","type":"main","index":0}]]},"If1":{"main":[[{"node":"Code in JavaScript1","type":"main","index":0}]]},"Loop Over Items3":{"main":[[],[{"node":"Jira Software","type":"main","index":0}]]},"editDescription1":{"main":[[{"node":"removeDuplicatesBasisOnDescription1","type":"main","index":0}]]},"Summary&Description1":{"main":[[{"node":"Loop Over Items3","type":"main","index":0}]]},"removeDuplicatesBasisOnDescription1":{"main":[[{"node":"Summary&Description1","type":"main","index":0}]]},"Jira Software":{"main":[[{"node":"Loop Over Items3","type":"main","index":0}]]},"When clicking ‘Test workflow’":{"main":[[{"node":"HTTP Request","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"fd778818-7331-4dc2-aa1c-325bae25b3f4","triggerCount":0,"tags":[]}